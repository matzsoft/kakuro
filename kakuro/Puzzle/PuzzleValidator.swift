//
//  PuzzleValidator.swift
//  kakuro
//
//  Created by Mark Johnson on 4/27/18.
//  Copyright Â© 2018 matzsoft. All rights reserved.
//

import Foundation

// This table gives the minimum and maximum number of empty cells for each valid kakuro total.
// The valid totals range from 3 (1+2) thru 45 (sum(1...9)).
// The table was generated by a very simple program using linear programming techniques utilizing two
// simple rules. First, the smallest total that can have a max of n is the sum of the lowest n digits.
// Second, the hightest total that can have a min of n is the sum of the highest n digits.

fileprivate let totalRanges: [ ( min: Int, max: Int ) ] = [
    ( min: 0, max: 0 ), ( min: 0, max: 0 ), ( min: 0, max: 0 ),     // 0, 1, 2 - not used
    ( min: 2, max: 2 ), ( min: 2, max: 2 ), ( min: 2, max: 2 ),     // 3, 4, 5
    ( min: 2, max: 3 ), ( min: 2, max: 3 ), ( min: 2, max: 3 ),     // 6, 7, 8
    ( min: 2, max: 3 ), ( min: 2, max: 4 ), ( min: 2, max: 4 ),     // 9, 10, 11
    ( min: 2, max: 4 ), ( min: 2, max: 4 ), ( min: 2, max: 4 ),     // 12, 13, 14
    ( min: 2, max: 5 ), ( min: 2, max: 5 ), ( min: 2, max: 5 ),     // 15, 16, 17
    ( min: 3, max: 5 ), ( min: 3, max: 5 ), ( min: 3, max: 5 ),     // 18, 19, 20
    ( min: 3, max: 6 ), ( min: 3, max: 6 ), ( min: 3, max: 6 ),     // 21, 22, 23
    ( min: 3, max: 6 ), ( min: 4, max: 6 ), ( min: 4, max: 6 ),     // 24, 25, 26
    ( min: 4, max: 6 ), ( min: 4, max: 7 ), ( min: 4, max: 7 ),     // 27, 28, 29
    ( min: 4, max: 7 ), ( min: 5, max: 7 ), ( min: 5, max: 7 ),     // 30, 31, 32
    ( min: 5, max: 7 ), ( min: 5, max: 7 ), ( min: 5, max: 7 ),     // 33, 34, 35
    ( min: 6, max: 8 ), ( min: 6, max: 8 ), ( min: 6, max: 8 ),     // 36, 37, 38
    ( min: 6, max: 8 ), ( min: 7, max: 8 ), ( min: 7, max: 8 ),     // 39, 40, 41
    ( min: 7, max: 8 ), ( min: 8, max: 8 ), ( min: 8, max: 8 ),     // 42, 43, 44
    ( min: 9, max: 9 ),                                             // 45
]

class PuzzleValidator: Puzzle {
    var errors: [ String ] = []
    
    convenience init(with puzzle: Puzzle) {
        self.init()
        cells = puzzle.cells
    }
    
    var isValid: Bool {
        errors = []
        
        guard nrows > 0 else {
            errors.append("puzzle is empty")
            return false
        }
        
        for row in 0 ..< nrows {
            if cells[row].count != ncols {
                errors.append("Row \(row + 1) has incorrect length")
            }
        }
        guard errors.count == 0 else { return false }
        
        for row in 0 ..< nrows {
            for col in 0 ..< cells[row].count {
                switch cells[row][col] {
                case is UnusedCell:
                    break
                case is EmptyCell:
                    validateEmptyCell(row: row, col: col)
                case let header as HeaderCell:
                    validateHeaderCell(header: header, row: row, col: col)
                default:
                    cellError(row: row, col: col, error: "has unknown cell type")
                }
            }
        }
        
        return errors.count == 0
    }
    
    private func cellError( row: Int, col: Int, error: String) {
        errors.append("Cell \(row+1),\(col+1): \(error)")
    }
    
    private func validateEmptyCell(row: Int, col: Int) {
        if row == 0 || col == 0 {
            cellError(row: row, col: col, error: "is orphaned")
        } else {
            let leftCell = cells[row][col-1]
            let upCell = cells[row-1][col]
            
            if leftCell is UnusedCell || upCell is UnusedCell {
                cellError(row: row, col: col, error: "is orphaned")
            } else {
                if leftCell is HeaderCell {
                    let header = leftCell as! HeaderCell
                    
                    if header.horizontal == nil {
                        cellError(row: row, col: col, error: "is orphaned")
                    }
                }
                if upCell is HeaderCell {
                    let header = upCell as! HeaderCell
                    
                    if header.vertical == nil {
                        cellError(row: row, col: col, error: "is orphaned")
                    }
                }
            }
        }
    }
    
    private func validateHeaderCell(header: HeaderCell, row: Int, col: Int) {
        if header.hasNoTotal() {
            cellError(row: row, col: col, error: "has no total")
        } else {
            switch row {
            case nrows - 1:
                if header.vertical != nil {
                    cellError(row: row, col: col, error: "unallowed vertical total")
                }
            case 0:
                if header.horizontal != nil {
                    cellError(row: row, col: col, error: "unallowed horizontal total")
                }
                fallthrough
            default:
                validateVerticalTotal(header, row: row, col: col)
            }
            switch col {
            case cells[row].count - 1:
                if header.horizontal != nil {
                    cellError(row: row, col: col, error: "unallowed horizontal total")
                }
            case 0:
                if header.vertical != nil {
                    cellError(row: row, col: col, error: "unallowed vertical total")
                }
                fallthrough
            default:
                validateHorizontalTotal(header, row: row, col: col)
            }
        }
    }
    
    private func validateHorizontalTotal(_ header: HeaderCell, row: Int, col: Int) {
        guard var sum = header.horizontal else { return }
        var cells: [EmptyCell] = []
        
        for newCol in col + 1 ..< self.cells[row].count {
            guard let cell = self.cells[row][newCol] as? EmptyCell else { break }
            
            cell.horizontal = header
            cells.append(cell)
        }
        
        sum.setCells(cells: cells)
        header.horizontal = sum
        
        if cells.count < totalRanges[sum.total].min {
            cellError(row: row, col: col, error: "not enough empty cells on the right")
        } else if cells.count > totalRanges[sum.total].max {
            cellError(row: row, col: col, error: "too many empty cells on the right")
        }
    }
    
    private func validateVerticalTotal(_ header: HeaderCell, row: Int, col: Int) {
        guard var sum = header.vertical else { return }
        var cells: [EmptyCell] = []

        for newRow in row + 1 ..< nrows {
            guard let cell = self.cells[newRow][col] as? EmptyCell else { break }
            
            cell.vertical = header
            cells.append(cell)
        }
        
        sum.setCells(cells: cells)
        header.vertical = sum
        
        if cells.count < totalRanges[sum.total].min {
            cellError(row: row, col: col, error: "not enough empty cells below")
        } else if cells.count > totalRanges[sum.total].max {
            cellError(row: row, col: col, error: "too many empty cells below")
        }
    }
}
